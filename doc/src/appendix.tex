\section{Kepler solver for elliptical orbits}
\label{ap:kepler-elliptical}
\begin{lstlisting}[language=C]
E = (e > 0.8) ? PI : M;
int d = 0
int iterations = 0
while (|d| > DEL_E)
{
    d = E - e * sin(E) - M;
    if (iterations -1 >= KEPLER_ITE)
        break
    E = E - d / (1.0 - e * cos(E))
    iterations++
}
\end{lstlisting}


\section{Kepler solver for Hyperbollic/Parabolic orbits}
\label{ap:kepler-hyperbollic}

\begin{lstlisting}[language=C]
double kepler(const double ecc, double mean_anom)
{
    double curr, err;
    int is_negative = 0, n_iter = 0;

    if(!mean_anom)
        return(0.);

    if(ecc < .3)     /* low-eccentricity formula from Meeus,  p. 195 */
    {
        curr = atan2(sin(mean_anom), cos(mean_anom) - ecc);
        /* one correction step,  and we're done */
        err = curr - ecc * sin(curr) - mean_anom;
        curr -= err / (1. - ecc * cos(curr));
        _exit_function();

        return(curr);
    }

    if(mean_anom < 0.)
    {
        mean_anom = -mean_anom;
        is_negative = 1;
    }

    curr = mean_anom;
    if((ecc > .8 && mean_anom < M_PI / 3.) || ecc > 1.)    /* up to 60 degrees */
    {
        double trial = mean_anom / fabs(1. - ecc);

        if(trial * trial > 6. * fabs(1. - ecc))   /* cubic term is dominant */
        {
            if(mean_anom < M_PI)
                trial = pow(6. * mean_anom, 1.0/3.0);
            else        /* hyperbolic w/ 5th & higher-order terms predominant */
                trial = asinh(mean_anom / ecc);
        }
        curr = trial;
    }

    double thresh = DEL_E_HYP * mean_anom;
    if(ecc < 1.)
    {
        err = (curr - ecc * sin(curr)) - mean_anom;
        while(fabs(err) > thresh)
        {
            n_iter++;
            curr -= err / (1. - ecc * cos(curr));
            err = (curr - ecc * sin(curr)) - mean_anom;

            if(n_iter > MAX_ITER) // amended
            {
                printf(
                    "#### ! Aborting kepler solution after %d iterations, keeping error of %e (e=%e, M=%e, E_=%e) ####\n",
                    MAX_ITER, err,
                    ecc, mean_anom, curr);
                break;
            }
        }
    }
    else
    {
        curr = log(2.*mean_anom/ecc+1.8); // taken from Burkardt & Danby, CeMec 31 (1983), 317-328
        double curr_abs = fabs(curr);
        err = (ecc * sinh(curr) - curr) - mean_anom;
        while(fabs(err) > thresh)
        {
            n_iter++;
            if(curr_abs < .72 && ecc < 1.1)
            {
                // [e * sinh(E) - E] / E << 1, and/or e * cosh(E) - 1 << 1
                // so don't calculate it directly
                double curr2 = curr * curr;

                // relative error when omitting nth order term needs to be smaller than resolution 1.e-15:
                // .5 * E^2 > 1e15 * E^n/n!, i.e. E < (n!/2e15)^(1/(n-2))
                // n = 16: E < .72, n = 10: E < .08

                if(curr_abs > .08)
                    curr -= err / ((ecc - 1) * cosh(curr) +
                            (((((((_1_16_15 * curr2 + 1.)
                            * _1_14_13 * curr2 + 1.)
                            * _1_12_11 * curr2 + 1.)
                            * _1_10_9 * curr2 + 1.)
                            * _1_8_7 * curr2 + 1.)
                            * _1_6_5 * curr2 + 1.)
                            * _1_4_3 * curr2 + 1.)
                            * .5 *curr2);
                else
                    curr -= err / ((ecc - 1) * cosh(curr) +
                            ((((_1_10_9 * curr2 + 1.)
                            * _1_8_7 * curr2 + 1.)
                            * _1_6_5 * curr2 + 1.)
                            * _1_4_3 * curr2 + 1.)
                            * .5 *curr2);
                curr2 = curr * curr;
                curr_abs = fabs(curr);

                if(curr_abs > .08)
                    err = ((ecc - 1) * sinh(curr) +
                            (((((((_1_17_16 * curr2 + 1.)
                            * _1_15_14 * curr2 + 1.)
                            * _1_13_12 * curr2 + 1.)
                            * _1_11_10 * curr2 + 1.)
                            * _1_9_8 * curr2 + 1.)
                            * _1_7_6 * curr2 + 1.)
                            * .05 * curr2 + 1.)
                            * _1_3_2 * curr2 * curr) - mean_anom;
                else
                    err = ((ecc - 1) * sinh(curr) +
                            ((((_1_11_10 * curr2 + 1.)
                            * _1_9_8 * curr2 + 1.)
                            * _1_7_6 * curr2 + 1.)
                            * .05 * curr2 + 1.)
                            * _1_3_2 * curr2 * curr) - mean_anom;
            }
            else
            {
                curr -= err / (ecc * cosh(curr) - 1.);
                err = (ecc * sinh(curr) - curr) - mean_anom;
            }
            if(n_iter > MAX_ITER) // amended
            {
                printf(
                    "### Aborting hyperbolic kepler solution after %d iterations, keeping error of %e (e=%e, M=%e, E_=%1.12e, sinh(E_)=%1.12e)\n",
                    MAX_ITER, err,
                    ecc, mean_anom, curr, sinh(curr));

                break;
            }
        }
     }

    return(is_negative ? -curr : curr);
}
\end{lstlisting}
